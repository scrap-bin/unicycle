## Контейнер зависимостей

### Используемые интерфейсы

`R2\DependancyInjection\ContainerInterface`  

`R2\DependancyInjection\ContainerAwareInterface`  

`R2\Config\LoaderInterface`


### Основные сведения

Контейнер помогает упростить управление зависимостями проекта.
Контейнер реализует шаблоны проектирования ["Сервис-локатор"](http://en.wikipedia.org/wiki/Service_locator_pattern)
и ["Ленивая загрузка"](http://en.wikipedia.org/wiki/Lazy_loading): 
когда нам нужен некий сервис, например Переводчик, мы просто говорим *"дай нам Переводчика"*. 
Так мы откладываем связывание на время исполнения и разрываем жесткую зависимость между классами.  
Подразумевается, что есть некая "конфигурация" где описаны сервисы. Если нам потребуется заменить сервис
на другой с тем же интерфейсом, мы сделаем это в конфигурации, а не в исходном коде классов.

При всем удобстве Сервис-локатор имеет и темную сторону. 
М. Фаулер [рекомендует](http://martinfowler.com/articles/injection.html#ServiceLocatorVsDependencyInjection) 
использовать его в ограниченном контексте. 

> Локатор может скрыть зависимости от других реализаций, но вы должны что-то знать о самом Локаторе.
Таким образом, выбор между Локатором и Инжектором зависит от того, какую из зависимостей вы избегаете.

Мы принимаем соглашение, что Контейнер будет упоминаться исключительно в 
[Service Layer](http://martinfowler.com/eaaCatalog/serviceLayer.html) — ему соответствует пространство имен 
`R2\Application`.  
После того как Приложение или Контроллер извлекли из Контейнера нужный объект, этот объект может быть внедрен
в другие объекты через ["инъекцию зависимостей"](http://en.wikipedia.org/wiki/Dependency_injection) — то есть
через конструкторы и сеттеры. Другие объекты уже ничего не должны знать про Контейнер.


### Конфигурация контейнера

Есть разные варианты представления конфигурации. Загрузку различных форматов обеспечивают классы,
реализующие интефрейс `LoaderInterface`. Мне больше всего нравится формат YAML, но вы можете выбрать свой.
Чтобы нейтрализовать медленный парсинг файлов конфигурации, применется кеширующий декоратор.

**Кусочек конфигурации для примера:**

```yaml
parameters:
    languages:
        - {label: English, synonym: English, locale: en_US, short_label: en}
        - {label: Русский, synonym: Russian, locale: ru_RU, short_label: ru}
    default_lang: ru
    fallback_lang: en

services:
    i18n:
        class: R2\Translation\Translator
        arguments: ["@i18n_loader", "%fallback_lang%"]
        settings: { setLocale: ["%default_lang%"] }
    i18n_loader:
        class: R2\Application\LangLoader
        arguments: ["%root_dir%/translations", "%root_dir%/cache"]
```

Секции *parameters* и *services* имеют особое значение. В параметрах задаются основные переменные величины, а
сервисы описывают способ создания объектов-по-требованию. В примере видны ссылки на другие пункты конфигурации:

* "@i18n_loader" — будет заменен на соответсвующий сервис. так можно задать цепочки автоматически создаваемых
  объектов;
* "%default_lang%" — будет заменен на значение из `parameters.default_lang`

Несколько параметров, например `parameters.root_dir` вычисляются при старте приложения и добавляются в конфигурацию.


### Методы контейнера

```php
interface ContainerInterface
{
    public function get($id);
    public function set($id, $service);
    public function getParameter($name);
    public function setParameter($name, $value);
}
```

**get()** добыват сервис. В зависимости от конфигурации объект может создаваться всякий раз заново или
будет использоваться один и тот же. В примере выше метод createSharedService указывает на то, что `i18n`
будет общий на все вызовы. Вместо него можно указать createService, если надо создавать копии сервиса.
По умолчанию используется createSharedService.

**getParameter()** добывает переменную величину. Путь до нее записывается в точечной нотации, например как
*'parameters.default_lang'*.

**set()** и **setParameter()** соответственно записывают сервис и переменную для последующего использования.
